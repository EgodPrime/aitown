# 产品需求文档（PRD） — AI 小镇（初版）

版本: 0.1
作者: PM
日期: 2025-10-05

<!-- 项目元信息（请由 PM/PO 确认或替换为具体值） -->
- Project Level: 2
- Greenfield: true
- Target date / Milestone: 2025-12-01 (可选，估算)
- Team size (initial): 2 devs + 1 PM

## 一、概述

目标：构建一个在局域网内运行的多人观察型沙盒，玩家可以在浏览器中创建并配置 LLM 驱动的 NPC，观察 NPC 在固定地图中生活、工作与社交。系统以“玩家创造 NPC，观察小镇”为核心互动模式。

重要调整（已由产品决策）:
- 服务器为所有 NPC 提供默认的 OpenAI 兼容 LLM（可配置）；在 MVP 中，LLM 与其他关键系统参数通过启动时读取的默认配置文件（例如 `config.yaml` 或环境变量）进行设置并生效，运行时不依赖管理员接口或管理员手动配置。玩家不得为自己的 NPC 提供或上传私有 OpenAI 兼容 API 连接信息。
- 仿真不可暂停或恢复；小镇时间会持续流逝，系统设计为持续运行（MVP 不依赖运行时管理员来控制仿真）。
-- 玩家修改 NPC 的 prompt 后，变更不会总是立即反映为行为改变；NPC 会在随时间推进的仿真步中基于新 prompt 逐步调整行为。仿真采用内部 Event Bus：每次决策首先被解析为对内部动作函数（action function）的调用描述（包含动作类型与参数），该调用描述作为事件写入 Event Bus。事件由引擎的事件消费者读取并实际执行对应的动作函数；动作执行完成后，执行结果（状态变更、交易记录、inventory 更新等）被写入事件日志并用于更新内存快照，这些状态变更在下一次仿真迭代时生效。
- 每个玩家只能拥有且管理一个 NPC，且只能编辑自己的 NPC（边界由会话或玩家标识控制）。
- 前端在 MVP 中可简化为文本驱动的展示：NPC 信息、小镇地点、时间与社交事件均以文本形式呈现，不要求头像或立绘。

### 简要背景

为在局域网环境快速验证 LLM 与仿真结合的可行性与用户体验，本项目通过 MVP 提供玩家在浏览器中创建、删除与编辑 NPC 的 prompt，并观察小镇的持续仿真运行。我们将在早期用户群中验证行为多样性、交互可理解性与系统稳定性（目标并发：10 个 NPC），以便决定是否推进到更完整的架构与多机部署。


背景与动机：本项目旨在展示 LLM 与模拟的结合，提供沉浸式但低交互门槛的体验，适合教育演示、AI 社区实验与本地局域网社交演示。

受众：本地小型用户群（家庭/教育/黑客松参与者），对 AI、模拟与轻量多人体验感兴趣的用户。

成功指标：
- 基本功能可用：用户能创建 NPC、修改其 prompt，并能看到 NPC 在地图上基于 prompt 的行为变化（移动、工作、社交、发言）。
- 稳定运行（MVP 目标）：在单机/小型局域网环境下，支持 10 个 NPC 的并发仿真与消息广播（目标负载）。
- 压力测试目标（stretch）：在优化后可支持 20-50 个 NPC 的并发仿真与消息广播（非 MVP 必需，作为性能目标）。
- 可演示 LLM 驱动的行为多样性（通过 prompt 可观察不同模式）。

新增成功指标（资源与经济相关）：
- NPC 能够管理基本生存属性（饱食度、能量、心情），这些属性归零将导致 NPC 死亡（仿真中移除/标记）。
- NPC 拥有包裹（inventory）与金钱（currency）系统，能够携带物品并用于购买/消费。
- NPC 能通过工作赚取金钱，且每天会收到服务器发放的基础生存保障金（可配置数量）。

时间与动作速率（成功指标相关）:
- 小镇时间流速：现实世界 36 分钟 = 小镇 1 天（24 小时模拟）。这意味着一天将分配为仿真日轮转周期，管理日结与保障金发放。
- NPC 行动频率：每个 NPC 每 90 秒可执行一次行动（行为决策与执行在该时间点产生并广播状态更新）。

注：NPC 的“决策”并非仅为文本记录；决策结果将在仿真引擎内部被转换为对系统动作函数的调用描述（internal action functions descriptor）。这些调用描述被序列化并写入 Event Bus 作为事件；事件消费者读取后实际执行对应的动作函数，动作函数负责修改 NPC 的数据结构（例如 `hunger`、`energy`、`location`、`inventory`、`money` 等）并产生相应副作用（比如物品变化、交易、社交关系更新）。动作执行完成后，执行结果（包括状态变更与交易记录）将被写入事件日志并用于生成内存快照，从而保证原子性与快照一致性（见 FR008 的验收准则）。

## 二、目标与范围
本 PRD 专注于 MVP（最小可行产品）:

### 部署意图

- MVP（面向早期用户）

### 主要目标

1. 用户能创建、删除、编辑 NPC 的 prompt
2. 用户能观察小镇的持续运行（仿真持续推进，实时/近实时事件流可见）
3. 支持 10 个 NPC 并发的稳定仿真（MVP 目标）；将 20-50 作为压力测试目标

本 PRD 专注于 MVP（最小可行产品）:
 - 服务器为所有 NPC 提供默认 OpenAI 兼容 LLM；在 MVP 中，系统通过启动配置文件读取并应用 LLM 配置；玩家不得上传或注册私有 OpenAI 兼容 API。
- 玩家可以在浏览器创建 NPC（每位玩家仅限 1 个）并编辑自己 NPC 的 prompt
- NPC 的行为由后端仿真循环驱动，prompt 更新将在随时间推进的仿真步中生效（非即时必然生效）
-- 后端通过 WebSocket 推送文本格式的状态与事件更新（前端以文本方式呈现）

## 简单用户旅程

（Level 2 要求）下面是主要的单一用户旅程，用于描述玩家从进入产品到观察 NPC 行为的主流程：

1. 玩家打开浏览器并访问小镇页面。页面展示当前小镇时间、NPC 列表与事件流。
2. 玩家点击“创建 NPC”并填写名称与初始 prompt（可选：性别、年龄）。提交后后端创建 NPC 并返回新对象，前端在列表中显示（收到 `npc_created` 事件）。
3. 玩家在自己的 NPC 页面查看实时状态快照（hunger/energy/mood/money）与最近事件（memory_log 的 recent_memory）。
4. 玩家编辑 NPC 的 prompt 并保存；界面立即显示最新 prompt（但行为变化将在随后仿真步中逐步生效）。
5. 系统的仿真循环按节奏（默认 90 秒）为该 NPC 生成新决策并通过 WebSocket 广播 `state_update`，前端展示状态变化与事件。
6. 玩家观察 NPC 行为变化（例如去餐馆、工作、社交），并在事件流中看到交易与社交摘要。
7. 玩家在需要时删除并重新创建 NPC（遵守一位玩家一 NPC 的规则）。

更多的旅程场景（例如多 NPC 交互、地点驱动任务）将录入到 `epic-stories.md` 中作为史诗与故事的来源。

扩展功能（MVP 内涉及但需明确实现方式）:
- NPC 基本属性：每个 NPC 维护饱食度（hunger）、能量（energy）、心情（mood）。这些属性随时间与行为变化降低或提升。若任一关键属性归零，NPC 将死亡并从活动列表中被标记/移除；玩家可以通过删除并重新创建一个 NPC（遵守每玩家一位的规则）来继续参与。
- 经济与物品：NPC 有 `money` 字段与 `inventory`（包裹）；物品（例如食物）可以存放于包裹中，食物消费可以恢复饱食度/能量。金币（money）用于在地点购买物品或服务。
- 工作与保障金：NPC 可以在某些地点（例如餐馆）执行“打工”任务来赚取金钱；此外服务器每天（按仿真日）发放基础生存保障金到每个 NPC 的账户（数量与是否启用可配置）。
- 社交关系：NPC 有社交关系表（social_relations），记录与其他 NPC 的关系（例如 friend, neutral, enemy）以及亲密度分数。关系只会在 NPC 实际相遇或发生交互后建立或改变。
- 地点功能化：小镇包含多种地点（餐馆、市场、广场、工厂等）；每种地点根据性质提供不同功能（例如餐馆可以消费或打工，市场可以买卖物品，广场是社交热点）。

明确不在 MVP 范围内的项（可后续迭代）:
- 用户登录/鉴权
- 永久存储与多机部署（可选 Postgres）
- 商业化特性（付费、社交平台分享等）

## 三、用户故事（示例）

1. 作为一个玩家，我希望在浏览器中创建一个 NPC（仅限一个），并为其设置 prompt，这样我可以观察它在小镇中的行为。
2. 作为一个玩家，我知道我不能暂停/恢复仿真（这是管理员操作），小镇的时间会持续流逝。
3. 作为一个玩家，我希望能修改已创建 NPC 的 prompt，但我理解行为变化基于仿真时间推进逐步生效（非即时保证）。

## 四、MVP 功能列表（高优先级）

### 功能性需求（核心 FR）

FR001 — 创建 NPC
- 描述：通过 POST /npc 创建 NPC（body: { name, prompt, gender?, age? }）。请求需携带 player_id/session；每位玩家仅允许存在一条活跃 NPC。
- 验收准则：成功返回 201 与完整 NPC 对象；系统广播 WebSocket 事件 `npc_created` 到相关订阅客户端；若玩家已存在活跃 NPC 则返回 409。

FR002 — 删除 NPC
- 描述：玩家可删除自己拥有的 NPC（DELETE /npc/{id}）。仅资源所有者或管理员可执行。
- 验收准则：成功返回 200 并广播 `npc_deleted`；非所有者返回 403。删除应清理内存状态与短期缓存，但保留不可变审计记录（事件日志）。

FR003 — 更新 prompt（仅对玩家可见，不对其他玩家广播）
- 描述：玩家可修改自己 NPC 的 prompt（PATCH /npc/{id}/prompt）。更新应立即在玩家界面反映为“最新 prompt”，但不通过 WebSocket 广播给其他客户端。行为影响在下一个或后续仿真步生效。
- 验收准则：成功返回 200 与更新对象；系统不发送 `npc_updated` 广播给其他玩家；更新在请求者的会话或随后的 GET /npc/{id} 中可见。

FR004 — 核心状态与 state_update 格式
- 描述：服务端维护每个 NPC 的状态（hunger, energy, mood, money, inventory, location 等），并按仿真节奏生成行为。State updates 通过 WebSocket 广播，消息包含 timestamp、npc_id、delta_changes 与新状态快照。
- 验收准则：每个仿真步（默认 90 秒）向相关订阅客户端发送 `state_update`；消息应包含 timestamp 与版本号以支持去重/幂等性。系统在网络或 LLM 延迟下应保证最终一致性。

FR005 — 并发目标与 LLM 回退策略
- 描述：仿真与 LLM Adapter 的设计应支持 MVP 并发目标 10 个 NPC。对于真实 LLM 调用的高延迟或失败，系统需回退到本地规则或简化行为生成以维持仿真节奏。
- 验收准则：在典型本地环境下，10 个 NPC 每 90 秒完成决策周期；当 LLM 请求失败或超时（例如 5s 超时阈值）时，应使用本地策略产生行为并记录回退事件（事件日志标注 `local-fallback`）。

FR006 — LLM 配置与审计（MVP: 启动配置，运行时只读）
- 描述：MVP 模式下，LLM 与关键系统参数在系统启动时从默认配置文件读取（如 `config.yaml`、环境变量或指定的启动目录）。运行时的动态配置修改（例如通过 Admin API）不是 MVP 必需项，但可以作为后续迭代功能引入。玩家不允许上传或注册私有 API。
- 验收准则：系统在启动时成功读取并日志记录所用配置来源；普通玩家无法在运行时更改 LLM 配置（尝试返回 403 或 400，并在文档中记录为“不支持的操作”）。

FR007 — 只读展示与 API contract
- 描述：提供只读接口用于前端与调试： GET /npc (分页)、GET /npc/{id}、GET /places、GET /npc/{id}/relations、GET /npc/{id}/memory。接口应公开响应 schema，并支持分页与缓存头。
- 验收准则：所有只读接口返回 200 且响应符合定义 schema；列表端点支持分页（limit/offset 或 cursor）。

FR008 — 行为生成与持久化语义
- 描述：行为由 LLM Adapter 或回退本地规则生成。行为结果必须：1) 应用到 NPC 内存状态，2) 写入事件日志（便于回放/审计），3) 广播 `state_update`。内存存储应支持 snapshot/versioning。
- 验收准则：每次行为生成必须产生日志记录并在 5s 内写入内存快照；在 LLM 回退情况下仍需写入事件并标注来源为 `local-fallback`。

注：在实现层面，行为生成的语义结果将由仿真引擎映射为对内部动作函数（internal action functions）的调用；这些函数负责执行对 NPC 状态的具体修改并保证在写入快照前完成所有关联副作用（交易、inventory 更新、社交变化等）。行为应用应在写入快照与广播之前完成，并在事件日志中标注变更来源与版本号以支持审计和回放。

FR009 — 仿真日结与保障金
- 描述：在每个仿真日轮转（按仿真时钟）时，系统向所有存活 NPC 发放基础保障金并在事件日志中记录交易。
- 验收准则：在轮转事件发生后 1s 内产生入账事件日志；GET /npc/{id}/transactions 可查询到该入账记录。

FR010 — 管理端与运行模式（MVP: 启动配置，无需运行时管理员）
- 描述：MVP 优先采用启动时配置策略，系统在启动时加载默认配置（包含 LLM 设置、仿真参数等）并持续运行，不依赖实时管理员操作。后续迭代可引入管理员 API（如运行时配置变更、审计查询或运维控制），但这些不是 MVP 必需。
- 验收准则：系统在启动时加载并报告配置来源；在无管理员模式下运行时，系统不暴露 pause/start 控制接口（任何尝试访问应返回明确的不支持错误），并且普通玩家无权限修改关键配置。


4.1 NPC 管理
- 创建 NPC（每位玩家仅能创建 1 个，客户端仅可提交字段：`name`, `gender` (可选), `age` (可选), `prompt`。服务器在创建时将 `profession` 初始化为 `平民`，并将 NPC 放置在小镇广场。）
- 列表查看小镇中的所有 NPC（只读）
- 更新 NPC 的 prompt（仅限编辑自己拥有的 NPC）
- 删除 NPC（仅限删除自己拥有的 NPC）

4.1.1 NPC 属性与库存
- 每个 NPC 包含基本生存属性：`hunger`（饱食度）、`energy`（能量）、`mood`（心情）。
- 每个 NPC 包含 `money`（数值）和 `inventory`（物品列表，条目包含 id、name、type、效果等）。
- NPC 死亡规则：任一关键生存属性（如饱食度或能量）降到 0 → NPC 被标记为已死亡并从活动列表中移除；只有玩家或管理员可以重新创建新的 NPC（仍受每玩家 1 个限制）。

4.2 仿真引擎
- 后端周期性为每个 NPC 生成行为（通过 LLM Adapter）并更新其文本化状态/位置。后端将以 Node.js + TypeScript 实现仿真循环与异步 LLM 调用，以提高开发一致性、类型安全与前后端共享类型契约。
- 推荐使用 `express`（或 `fastify`）作为 HTTP API 层，使用 `ws` 作为 WebSocket 层（当前仓库已包含 `express` 与 `ws` 依赖）。对于广播性能，请实现房间/分区订阅（按地图切片或玩家房间）以减少广播面。
- 状态与事件更新以 WebSocket 文本消息广播给所有客户端；仿真全局控制（pause/start）仅限管理员通过命令行或受限管理接口执行；普通玩家无法通过前端控制仿真速度或暂停

4.2.2 时间与行动节奏
- 小镇时钟：系统应维护仿真时钟，设定为现实时间的比率为 36 分钟 = 1 仿真日，便于日结、工作与地点开放时间的计算。
- 行动间隔：每名 NPC 的决策/行动节奏为 90 秒一次（可配置测试参数），每次行动触发 LLM Adapter 调用并在完成后广播 `state_update`。

4.2.1 生存与经济交互
- 行为决策需考虑基本属性：LLM Adapter 在生成行为时会接收 NPC 的当前 `hunger/energy/mood/money/inventory/social_relations` 作为 context，以便生成更合理的行动（例如去餐馆吃饭、找工作、社交）。
- 物品交互：地点可出售/提供物品（例如食物），购买需消耗 `money`，消费对应影响生存属性。
- 工作行为：某些地点支持 `work` 动作，执行后会在 NPC 的 `money` 增加（工作收益可由地点类型和 NPC 状态影响），同时消耗能量。
- 每日保障金：仿真日轮转时，系统会向每个存活的 NPC 发放基础金额以确保最低生活（可配置）。

- 4.3 前端展示（MVP 简化为文本风格）
- 前端以文本为主：展示 NPC 列表（名称、所属玩家、prompt 摘要、当前状态文本）
- 小镇地点信息、时间线、社交事件均以时间序列文本或事件流展示
- 创建表单与 prompt 编辑器为简洁文本输入界面（无需头像/立绘）

- 4.3.1 前端应展示的重要文本信息
- NPC 基本属性：`hunger/energy/mood/money` 与关键物品摘要（例如是否携带食物）
- 时间与日夜周期：展示当前仿真时间、当天是否发放保障金等时间事件
- 地点功能提示：当玩家查看某地点时显示该地点的名称以及可达通路信息（仅名称或相邻地点的 `place_id`/`locationId`）。重要：不在前端展示地点的内部坐标（x/y）。地点间连通性由独立的 `IPath` 实体表示，前端可通过 `GET /paths` 查询直达通路；玩家无法直接通过坐标发起移动等操作。
- 社交事件日志：展示 NPC 之间的社交交互摘要（e.g., "A 遇见 B，成为朋友 +5"）

4.5 记忆与日志（NPC 记忆系统）
- 每个 NPC 维护一个按时间顺序的 `memory_log`（记忆日志）。每条 `IMemoryEntry` 包含 `recent_memory`（最近 7 天的短文本条目列表，格式为 "时间 - 主语 谓语 宾语"）和 `old_memory`（LLM 压缩的长期记忆摘要）。
- 记忆保留策略：系统保留 `recent_memory` 作为最近 7 天的详细条目；超过 7 天的历史记忆由 LLM 压缩为 `old_memory`。
- 访问与展示：玩家可以查看自己 NPC 的 `memory_log`（包括 `recent_memory` 与 `old_memory`），日志可用于调试、叙事呈现或作为监督依据。
- 存储与隐私：Memory log 存储为文本事件；若集成持久化，应考虑加密/访问控制（后续迭代）。

4.4 可配置 LLM 适配器
- 提供 mock 实现用于离线演示
- 提供 adapter 接口，便于接入 OpenAI 等

## 五、关键交互与流程（简要）

-- 玩家在前端填写创建表单 → 前端调用 POST /npc（请求需绑定玩家标识）→ 后端创建 NPC（或返回错误当玩家已有 NPC）并广播 npc_created → 所有客户端以文本方式更新界面
-- 后端仿真循环按时调用 LLM Adapter（默认使用服务器端 OpenAI 兼容 API 或玩家指定的 API，具体依配置）→ 更新 NPC 状态/位置并在仿真步中生效 → 广播 state_update
-- 仿真控制（pause/start）仅由管理员通过命令行或受限管理接口发起，普通玩家的 WebSocket `control` 消息将被忽略或返回权限错误

## 五点一、假设与外部依赖（Assumptions & Dependencies）

注意：下面列出的条目为在当前阶段的合理假设（已由文档作者推断）。若实际项目约束不同，请由 PM/PO 确认并替换为准确值。

- LLM 可用性: 服务器在启动时使用 `config.yaml` 中指定的默认 OpenAI 兼容 LLM。默认假设为：服务器允许对外网的 OpenAI 兼容终端进行调用（LLM 公网访问 = true）。如果部署在严格隔离的局域网中，应改为使用本地 Mock Adapter 或内部 LLM 并在 `config.yaml` 中配置相应适配器。
- 部署边界: MVP 目标为单机/局域网部署（single-node），服务可对局域网内客户端提供 WebSocket 与 HTTP 接口；若需要公网访问或托管，需在 tech-spec 中说明并配置网络/安全边界。
- 外部集成: MVP 不集成第三方支付或外部商店服务（外部支付集成 = none）。任何未来集成需在假设中声明并指派责任人。
- 配置与凭据管理: 所有关键参数（LLM 配置、超时阈值、并发目标等）由 `config.yaml` 或环境变量在启动时提供。获取第三方 API key（如需要）为团队责任（默认责任人: PM，由 Tech Lead 执行具体配置）。
- 依赖清单（Runtime & Infra）:
	1. Node.js 运行时（符合仓库 `package.json` 的指定版本）
	2. `express` + `ws` 或等效 HTTP/WebSocket 库
	3. 可选的外部 OpenAI 兼容 LLM 服务（或本地 Mock Adapter）
	4. 配置文件 `config.yaml` 在应用启动时可访问

若上述任何假设与实际情况不符，请回复需要修改的项（例如将 `LLM 公网访问` 改为 `false` 表示部署环境禁止对公网调用）。


## 六、数据与 API 设计（契约）

参见 `docs/game-spec.md` 中的 NPC 对象与 API 列表。后端迁移为 TypeScript 后，应将关键 API 的输入/输出契约以 TypeScript 接口/类型的形式保存在 `src/types` 或 `src/contracts` 中，便于前后端共享与静态检查；同时在运行时使用校验库（例如 zod / ajv / io-ts）进行边界校验以防止不良输入。补充 API 要点：

- 创建 NPC 时需包含 `player_id` 或会话标识，服务器据此限制每位玩家只能拥有一个 NPC
-- 注意（MVP 策略一致性）：MVP 明确禁止玩家上传或注册私有 OpenAI 兼容 API 连接信息。所有 LLM 调用在运行时均使用服务器端配置或启动时指定的默认 LLM；若后续版本允许玩家提供私有 API，需补充安全、加密、回退和隐私合规策略。

补充 API 要点（物品、工作、社交相关）:
- GET /places -> 返回小镇地点列表（只读）与每个地点的静态信息（价格/收益为参考）。
- 注意：以下交互（购买、使用物品、工作、移动等）均由 NPC 在后端仿真循环中自主决定并执行；这些行为不是玩家通过前端直接发起的操作。
	- NPC 行为（buy/use-item/work/move 等）由后端仿真或后台任务执行，变更将通过 WebSocket `state_update` 广播给所有客户端。前端不应展示直接触发这些动作的控件给普通玩家。
- GET /npc/{id}/relations -> 返回该 NPC 的社交关系列表（只读）

## 七、验收标准（每项均需可自动/人工验证）

7.1 基本 CRUD
- 创建 NPC：POST /npc（包含 player_id）返回新对象并且 WebSocket 推送 npc_created（验证: 前端文本显示新 NPC）。若玩家已有 NPC，则返回 400/冲突错误。
- 更新 prompt：POST /npc/{id}/prompt（仅允许 NPC 所有者）返回更新对象并且 WebSocket 推送 npc_updated（验证: 前端显示新 prompt，但行为变化基于仿真步而非即时必然生效）
- 删除 NPC：DELETE /npc/{id}（仅允许 NPC 所有者或管理员）返回 200 并且前端移除 NPC

7.1 补充验收（生存、经济、社交）
- 生存属性：创建 NPC，在不干预的情况下观察多日仿真，属性会随时间下降/变化；当 `hunger` 或 `energy` 达到 0 时 NPC 被标记为死亡并广播死亡事件
- 购买与物品：在商店地点购买食物后，消费该食物应恢复指定的 `hunger/energy` 值；购买会消耗 `money` 并把物品加入 `inventory`
- 工作收益与保障金：在工作地点执行 `work` 操作后，NPC 的 `money` 增加（收益合理）；每个仿真日结算时，所有存活 NPC 收到基础保障金并能在日志中看到入账记录
- 社交关系：当两名 NPC 在同一地点相遇时，会生成或更新社交关系（例如 friend 增加亲密度）；社交事件应在前端日志中可见

7.1.1 补充验收（时间与记忆）
- 时间刻度：确认现实 36 分钟等于仿真 1 天（通过观察仿真时钟与日结事件、保障金发放时序来验证）。
- 行动频率：在创建若干 NPC 后，验证每个 NPC 每 90 秒至少进行一次决策/行动并产生 `state_update` 广播（可以通过日志计数验证）。
- 记忆保留：创建 NPC 并运行多日仿真后，验证最近 7 天的逐日事件仍以详细条目保留，超过 7 天的历史以 LLM 摘要条目出现（可通过调用 `GET /npc/{id}/memory` 查看并比对原始事件/摘要）。

7.2 仿真与状态更新
-- 启动后端服务，创建 10 个 NPC，模拟 600 秒内至少出现状态更新（state_update）广播
-- 仿真 pause/start 控制由管理员在服务器端命令行或受限管理接口发起，普通玩家的控制请求不具备权限

7.3 前端展示
- 地图能展示 NPC 节点位置（坐标映射合理）
- 点击或查看 NPC 能看到其当前状态文本

## 八、非功能需求

- 性能：在单台机器上支持 50 个 NPC 并保证每 2 秒更新一次不导致后端明显阻塞。若使用真实 OpenAI API，需考虑调用延迟与并发配额；优先使用批量或并发限制策略并回退到本地规则以保证仿真节奏。
- 可用性：前端在断开重连后能拉取 full_state 并继续渲染
- 可维护性：LLM 适配器应采用插件式设计，便于替换

已量化的 NFR（建议，MVP/Short-term 指标）:

- LLM 超时阈值（请求超时时间）：5 秒（当 LLM 调用在 5s 内未返回，触发本地回退策略）。
- State update 广播延迟目标：95% 的 `state_update` 广播在 5 秒内到达订阅客户端（在本机网络条件下测量）。
- 决策总耗时目标（生成到动作应用）：在 10 个并发 NPC 的情况下，单个决策生成并应用（包含写快照）平均应 < 10 秒。
- 内存快照写入窗口：每次行为生成后的内存快照与事件日志应在 5 秒内完成写入以保证回放一致性。

说明：上述指标为初始目标，技术团队可在 solutioning 阶段调整为更严格或更宽松的阈值，并在 CI/CD 性能测试中验证。


## 九、风险与缓解措施

-- 风险：LLM API 调用延迟或失败 → 缓解：超时回退到本地规则/默认行为；（注：MVP 禁止玩家上传私有 API，因此不在 MVP 中实现对玩家私有 API 的验证与使用流程）
- 风险：WebSocket 广播成为瓶颈 → 缓解：实施房间/分片广播或使用消息代理

## 十、实施计划（里程碑） — TypeScript 后端迁移与交付

- Week 0: 需求确认与 PRD（当前）
- Week 1: TypeScript 后端原型（API + WebSocket + 内存仿真）
	- 在仓库中创建 `src/` TypeScript 服务（示例已有 `package.json` 支持 TypeScript + `express` + `ws`），包含 `src/index.ts`, `src/server.ts`, `src/simulator.ts`, `src/types`。
	- 提供 `npm run dev` 本地启动脚本（使用 `ts-node-dev`），并在 `README.md` 中记录开发启动步骤。
- Week 2: LLM Adapter 插件化、持久化方案（SQLite/Postgres 可选）
	- 添加 adapter 接口 `src/adapters/llm.ts`，实现 Mock adapter 与 OpenAI adapter 示例。
	- 将内存存储抽象为仓库接口 `src/repos/*` 并提供 SQLite（Prisma/knex）或 Postgres 的初始实现（可选）。
- Week 3: 前端增强与契约对齐
	- 在 `src/types` 中维护 TypeScript 接口，并导出 JSON Schema（或使用 TypeScript-to-Schema 工具）以便前端共享和运行时验证。

迁移注意事项：
- 保留现有 API 路径与消息格式以最小化前端改动；若需要变更，提供兼容层和迁移说明。
- 使用 TypeScript 的静态类型捕获契约不一致，同时在运行时使用验证库防止格式错误输入。
- CI：在 `package.json` 中加入 `npm run build`、`npm test`、`npm run lint` 步骤，并在 GitHub Actions（或同类 CI）中运行以保证主分支稳定。

示例 CI 流程（高层）:
- 安装依赖
- 运行 `npm run build`（TypeScript 编译）
- 运行单元/集成测试（Jest / Vitest / Playwright）
- 构建并发布 Docker 镜像（可选）

## 十一、开放问题（需要 PO/PM 确认）

1. 是否需要社交登录或多人协作的编辑权限控制？
2. 是否允许玩家导入/导出 NPC 配置？
3. 是否需要内置示例 prompt 库供新手使用？

---

现在我将把一个关键交互段（"MVP 功能列表 & 验收标准"）置于 elicit 交互：我会给出 1-9 的选项来帮助你细化 MVP 的部分（例如是否启用删除 NPC、是否需要示例 prompt、更新频率等）。

Advanced Elicitation Options
Choose a number (0-8) or 9 to proceed:

0. Expand or Contract for Audience
1. Critique and Refine
2. Identify Potential Risks and Unforeseen Issues
3. Agile Team Perspective Shift
4. Tree of Thoughts Deep Dive
5. Hindsight is 20/20 Reflection
6. Persona-Pattern Hybrid (PM + Risk Analysis)
7. Innovation Tournament (alternate MVP scopes)
8. Proceed / No Further Actions
9. Proceed / No Further Actions

Select 0-8 or 9, or type feedback/questions. 