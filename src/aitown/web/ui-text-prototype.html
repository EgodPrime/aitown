<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI 小镇 — 文本原型</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;line-height:1.5;margin:0;padding:0}
    .bar{background:#0b5d8a;color:#fff;padding:10px 14px}
    .layout{display:grid;grid-template-columns:240px 1fr 220px;gap:12px;padding:12px}
    .panel{background:#fff;border:1px solid #e6e6e6;padding:10px;border-radius:6px}
    .list-item{padding:8px;border-bottom:1px dashed #eee;cursor:pointer}
    .list-item:hover{background:#f6fbff}
    .badge{background:#eef6ff;padding:2px 6px;border-radius:4px;font-size:12px;margin-left:6px}
    .feed{max-height:240px;overflow:auto;font-size:13px}
    textarea{width:100%;height:90px}
    button{padding:8px 10px;border-radius:6px;border:0;background:#0b8bd6;color:#fff;cursor:pointer}
  </style>
</head>
<body>
  <div class="bar">Town Time: <span id="townTime">--</span> | Simulation: <span id="simState">--</span> | WS: <span id="wsState">--</span></div>
  <div class="layout">
    <div class="panel" id="npcList">
      <h3>NPC 列表</h3>
      <div id="list"></div>
      <hr />
      <h4>Create NPC</h4>
      <input id="nameIn" placeholder="name" />
      <div style="height:6px"></div>
      <textarea id="promptIn" placeholder="starting prompt"></textarea>
      <div style="height:6px"></div>
      <button id="createBtn">Create</button>
    </div>

    <div class="panel" id="detail">
      <h3 id="detailName">Select an NPC</h3>
      <div id="mapPanel" style="margin-bottom:8px"></div>
      <div id="detailBody">No NPC selected.</div>
      <hr />
      <h4>Prompt Editor</h4>
      <textarea id="promptEdit"></textarea>
      <div style="display:flex;gap:8px;margin-top:8px"><button id="savePrompt">Save Prompt</button><button id="refreshMem">Refresh Memory</button></div>
      <hr />
      <h4>Recent Memories (7 days)</h4>
      <div id="memList" style="max-height:180px;overflow:auto;font-size:13px"></div>
    </div>

    <div class="panel" id="actions">
      <h3>Actions</h3>
      <div id="actionsBody">Select an NPC to see actions.</div>
      <hr />
      <h4>Event Feed</h4>
      <div class="feed" id="feed"></div>
    </div>
  </div>

  <script>
    const API = (path, opts)=>fetch(path,opts).then(r=>r.json().catch(()=>null));
    let selected = null;

    function fmtState(n){return `h:${n.hunger||0} e:${n.energy||0} m:${n.mood||0} $${n.money||0}`}

    async function refreshList(){
      const listEl = document.getElementById('list');
      listEl.innerHTML='Loading...';
      const data = await API('/npc');
      listEl.innerHTML='';
      if(!data || !Array.isArray(data)) { listEl.innerText='No data'; return }
      data.forEach(n=>{
        const d = document.createElement('div'); d.className='list-item'; d.innerHTML=`${n.name} <span class="badge">${fmtState(n)}</span>`;
        d.onclick=()=>selectNPC(n.id);
        listEl.appendChild(d);
      })
    }

    async function selectNPC(id, centerPos){
      // centerPos optional: {x,y} to center the map on a specific cell
      const detail = document.getElementById('detailBody');
      detail.innerText='Loading...';
      const n = await API('/npc/'+id);
      if(!n){detail.innerText='Not found'; return}
      selected = n;
      document.getElementById('detailName').innerText = n.name;
      document.getElementById('promptEdit').value = n.prompt||'';
      detail.innerHTML = `<pre>${JSON.stringify({location:{x:n.x,y:n.y},state:n.state||{},money:n.money,inventory:n.inventory},null,2)}</pre>`;
      loadMemories(n.id);
      document.getElementById('actionsBody').innerHTML = `
        <div><button onclick="buyFood()">Buy Food</button></div>
        <div style="height:8px"></div>
        <div><button onclick="work()">Work</button></div>
      `;
      // render map centered on either NPC location or provided centerPos
      const cx = centerPos?.x ?? n.x ?? 0;
      const cy = centerPos?.y ?? n.y ?? 0;
      renderMap(cx,cy);
    }

    async function createNPC(){
      const name = document.getElementById('nameIn').value;
      const prompt = document.getElementById('promptIn').value;
      if(!name) return alert('name required');
      const res = await fetch('/npc',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({name,prompt,player_id:'ui-proto'})});
      const j = await res.json();
      addFeed('npc_created: '+(j.id||'?'));
      setTimeout(refreshList,400);
    }

    async function savePrompt(){
      if(!selected) return alert('select npc');
      const text = document.getElementById('promptEdit').value;
      await fetch('/npc/'+selected.id+'/prompt',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({prompt:text})});
      addFeed('prompt_updated for '+selected.name);
      setTimeout(()=>selectNPC(selected.id),600);
    }

    async function loadMemories(id){
      const m = await API('/npc/'+id+'/memory');
      const el = document.getElementById('memList'); el.innerHTML='';
      if(!m) { el.innerText='No memory'; return }
      (m.recent||m).forEach(day=>{
        const d = document.createElement('div'); d.innerHTML = `<b>${day.date}</b>: ${day.summary||day.events.join('; ')}`; el.appendChild(d);
      })
    }

    // cached places list
    let PLACES = [];
    async function refreshPlaces(){
      const p = await API('/places');
      PLACES = Array.isArray(p)?p:[];
    }

    // --- Map rendering & interactions (SVG) ---
    // Render a small SVG grid centered on cx,cy with visible neighbor lines
    function renderMap(cx,cy){
      const size = 5; // odd -> center
      const cellSize = 48;
      const gap = 6;
      const half = Math.floor(size/2);
      const mapEl = document.getElementById('mapPanel');
      mapEl.innerHTML = '';
      const totalW = size * cellSize + (size-1) * gap;
      const totalH = totalW;
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS,'svg');
      svg.setAttribute('width', totalW);
      svg.setAttribute('height', totalH);
      svg.style.borderRadius = '6px';
      svg.style.background = '#fff';

      // compute center pixel for a given rx,ry
      function cellXY(rx,ry){
        const px = (rx + half) * (cellSize + gap);
        const py = (ry + half) * (cellSize + gap);
        return {px,py};
      }

      // draw cells and text
      for(let ry=-half; ry<=half; ry++){
        for(let rx=-half; rx<=half; rx++){
          const cellX = cx + rx;
          const cellY = cy + ry;
          const {px,py} = cellXY(rx,ry);
          const rect = document.createElementNS(svgNS,'rect');
          rect.setAttribute('x', px);
          rect.setAttribute('y', py);
          rect.setAttribute('width', cellSize);
          rect.setAttribute('height', cellSize);
          rect.setAttribute('rx', 6);
          rect.setAttribute('ry', 6);
          rect.setAttribute('fill', (rx===0 && ry===0) ? '#eef6ff' : '#fafafa');
          rect.setAttribute('stroke', '#ddd');
          rect.setAttribute('data-coords', `${cellX},${cellY}`);
          // attach place id/name if there is a place whose x,y match
          const place = PLACES.find(q=>Math.round(q.x)===Math.round(cellX) && Math.round(q.y)===Math.round(cellY));
          if(place){ rect.setAttribute('data-place-id', place.place_id || place.id || place.name); rect.setAttribute('data-place-name', place.name); }
          rect.style.cursor = 'pointer';
          rect.addEventListener('click', ()=>onMapClick(cellX,cellY,cx,cy,rect.getAttribute('data-place-id')));
          svg.appendChild(rect);

          // text label
          const text = document.createElementNS(svgNS,'text');
          text.setAttribute('x', px + cellSize/2);
          text.setAttribute('y', py + cellSize/2 + 4);
          text.setAttribute('text-anchor','middle');
          text.setAttribute('font-size','11');
          text.setAttribute('fill','#333');
          text.textContent = (rx===0 && ry===0) ? 'YOU' : (PLACES.find(q=>Math.round(q.x)===Math.round(cellX) && Math.round(q.y)===Math.round(cellY)) ? PLACES.find(q=>Math.round(q.x)===Math.round(cellX) && Math.round(q.y)===Math.round(cellY)).name : '');
          svg.appendChild(text);
        }
      }

      // draw neighbor lines (from center to up/down/left/right)
      const neighbors = [ [0,-1],[0,1],[-1,0],[1,0] ];
      const centerXY = cellXY(0,0);
      const cxPx = centerXY.px + cellSize/2;
      const cyPx = centerXY.py + cellSize/2;
      neighbors.forEach(([rx,ry])=>{
        const nXY = cellXY(rx,ry);
        const nx = nXY.px + cellSize/2;
        const ny = nXY.py + cellSize/2;
        const line = document.createElementNS(svgNS,'line');
        line.setAttribute('x1', cxPx);
        line.setAttribute('y1', cyPx);
        line.setAttribute('x2', nx);
        line.setAttribute('y2', ny);
        line.setAttribute('stroke', '#0b8bd6');
        line.setAttribute('stroke-width', 2);
        line.setAttribute('stroke-opacity', 0.6);
        svg.appendChild(line);
      });

      // append svg
      mapEl.appendChild(svg);

      // refresh NPC list to show only NPCs at center cell or place
      refreshListFiltered(cx,cy);
    }

    async function refreshListFiltered(cx,cy){
      const listEl = document.getElementById('list');
      listEl.innerHTML='Loading...';
      const data = await API('/npc');
      listEl.innerHTML='';
      if(!data || !Array.isArray(data)) { listEl.innerText='No data'; return }
      const filtered = data.filter(n=>Math.round(n.x)===Math.round(cx) && Math.round(n.y)===Math.round(cy));
      if(filtered.length===0){ listEl.innerText='(no NPC at this cell)'; return }
      filtered.forEach(n=>{
        const d = document.createElement('div'); d.className='list-item'; d.innerHTML=`${n.name} <span class="badge">${fmtState(n)}</span>`;
        d.onclick=()=>selectNPC(n.id);
        listEl.appendChild(d);
      })
    }

    // force-move interaction
    async function onMapClick(tx,ty,cx,cy,placeId){
      // if clicked center -> do nothing; else if center has selected NPC, send force-move
      if(tx===cx && ty===cy) return;
      if(!selected){ addFeed(`View moved to ${tx},${ty}`); renderMap(tx,ty); return }
      // if clicked cell is void (no placeId) -> only focus
      if(!placeId){ addFeed(`Clicked empty cell ${tx},${ty} — view moved`); renderMap(tx,ty); return }
      addFeed(`Requesting force-move ${selected.name} -> place ${placeId}`);
      // prefer place_id based POST when available
      try{
        const body = { place_id: placeId };
        const res = await fetch(`/npc/${selected.id}/move`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
        if(res.status===200||res.status===201){ addFeed('force-move request accepted'); }
        else { addFeed('move API not accepted, sending WS control fallback'); wsSendControl({type:'control',action:'force_move',npc_id:selected.id,place_id:placeId,x:tx,y:ty}); }
      }catch(e){ addFeed('move API failed, sending WS control fallback'); wsSendControl({type:'control',action:'force_move',npc_id:selected.id,place_id:placeId,x:tx,y:ty}); }
    }

    // we keep a reference to ws for fallback control messages
    let _wsRef = null;
    function wsSendControl(msg){ if(_wsRef && _wsRef.readyState===1) _wsRef.send(JSON.stringify(msg)); else addFeed('no ws connection for control message'); }

    async function buyFood(){ if(!selected) return; await fetch('/npc/'+selected.id+'/buy',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({item_id:'food_basic',place_id:'market_1'})}); addFeed('buy_food -> '+selected.name); }
    async function work(){ if(!selected) return; await fetch('/npc/'+selected.id+'/work',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({place_id:'restaurant_1'})}); addFeed('work -> '+selected.name); }

    function addFeed(text){ const f=document.getElementById('feed'); const t=document.createElement('div'); t.innerText='['+new Date().toLocaleTimeString()+'] '+text; f.prepend(t); }

    document.getElementById('createBtn').onclick=createNPC;
    document.getElementById('savePrompt').onclick=savePrompt;
    document.getElementById('refreshMem').onclick=()=>selected && loadMemories(selected.id);

    // WebSocket for state_update
    try{
      const ws = new WebSocket((location.protocol==='https:'?'wss:':'ws:')+'//'+location.host+'/ws');
      _wsRef = ws;
      ws.onopen=()=>document.getElementById('wsState').innerText='Connected';
      ws.onclose=()=>document.getElementById('wsState').innerText='Closed';
      ws.onmessage=(ev)=>{
        try{const msg=JSON.parse(ev.data); if(msg.type==='state_update'){ addFeed('state_update: '+(msg.payload && msg.payload.type?msg.payload.type:JSON.stringify(msg.payload).slice(0,80))); refreshList(); if(msg.payload && msg.payload.npc_id && selected && selected.id===msg.payload.npc_id) selectNPC(selected.id);}}
        catch(e){ addFeed('ws:'+ev.data); }
      }
    }catch(e){document.getElementById('wsState').innerText='No WS';}

    // initial load
    refreshList();
    setInterval(()=>{document.getElementById('townTime').innerText=new Date().toLocaleString()},1000);
  </script>
</body>
</html>
