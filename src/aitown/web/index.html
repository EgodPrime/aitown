<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI 小镇</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://unpkg.com/@antv/g6@4.5.6/dist/g6.min.js"></script>
    <style>
      body { font-family: Arial, sans-serif; margin: 0; padding: 0 }
      #app { display:flex; height:100vh }
      #left { width: 300px; border-right:1px solid #ddd; padding: 12px; box-sizing:border-box }
      #map { flex:1 }
      .npc-item { padding:6px; border-bottom:1px solid #eee }
      .controls { margin-top:12px }
    </style>
  </head>
  <body>
    <div id="app">
  <div id="left">
        <h3>AI 小镇</h3>
        <div>
          <label>Player ID: <input v-model="form.player_id" /></label>
        </div>
        <div>
          <label>名称: <input v-model="form.name" /></label>
        </div>
        <div>
          <label>Prompt:<br/><textarea v-model="form.prompt" rows="4" style="width:100%"></textarea></label>
        </div>
        <div class="controls">
          <button @click="createNpc">创建 NPC</button>
          <button @click="toggleSimulation">{{ running ? '暂停' : '启动' }} 仿真</button>
        </div>
        <h4>NPC 列表</h4>
        <div v-for="npc in npcs" :key="npc.id" class="npc-item" @click="selectNpc(npc.id)">
          <strong>{{ npc.name }}</strong> <small>({{ npc.player_id }})</small><br/>
          h:{{ npc.hunger }} e:{{ npc.energy }} m:{{ npc.mood }} — {{ npc.state?.action }}
        </div>
      </div>
      <div style="flex:1; display:flex;">
        <div id="map" style="flex:1;display:flex;flex-direction:column">
          <div style="display:flex;flex:1">
          <div style="width:40%;padding:12px;box-sizing:border-box">
            <h4>Detail</h4>
            <div v-if="selected">
              <div><strong>{{ selected.name }}</strong> ({{ selected.player_id }})</div>
              <div>Prompt: {{ selected.prompt }}</div>
              <div>Location: {{ selected.location || (selected.x+','+selected.y) }}</div>
              <div>Money: {{ selected.money }}</div>
              <div>Inventory: <span v-for="it in selected.inventory">{{ it.item_id }} </span></div>
              <div style="margin-top:8px"><button @click="editPrompt()">Edit Prompt</button> <button @click="showMemory()">Show Memory</button></div>
            </div>
            <div v-else>Select an NPC to see details</div>
            <h4 style="margin-top:12px">Places</h4>
            <div v-for="p in places" :key="p.id">{{ p.name }} — items: {{ JSON.stringify(p.items) }}</div>
            <h4 style="margin-top:12px">Events</h4>
            <div style="max-height:200px;overflow:auto;background:#f9f9f9;padding:6px">
              <div v-for="e in events" :key="e.ts">[{{ e.ts }}] {{ e.txt }}</div>
            </div>
          </div>
          <div style="flex:1;padding:12px">
            <h4>Map (5x5)</h4>
            <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:4px;">
              <div v-for="cell in mapCells" :key="cell.k" @click="onCellClick(cell)" :style="{border:'1px solid #ccc',padding:'8px',minHeight:'48px',background: cell.center ? '#eef' : '#fff'}">
                <div>{{ cell.label }}</div>
                <div v-if="cell.place"><small>{{ cell.place.name }}</small></div>
              </div>
            </div>
            </div>

            <div style="width:260px;border-left:1px solid #ddd;padding:12px;box-sizing:border-box">
              <h4>Actions</h4>
              <div v-if="selected">
                <div style="margin-bottom:8px">Selected: <strong>{{ selected.name }}</strong></div>
                <div style="margin-top:8px">
                  <label>Edit Prompt:</label>
                  <textarea v-model="editPromptText" rows="3" style="width:100%">{{ selected.prompt }}</textarea>
                  <div style="margin-top:6px"><button @click="savePrompt">Save Prompt</button></div>
                </div>
              </div>
              <div v-else>Select an NPC to see actions</div>
            </div>
        </div>
        <div id="actions" style="width:260px;border-left:1px solid #ddd;padding:12px;box-sizing:border-box">
          <h4>Actions</h4>
          <!-- removed legacy/duplicate action set; all NPC behavior is autonomous except prompt editing -->
      </div>
    </div>

    <script>
      const { createApp, ref, onMounted } = Vue
      createApp({
        setup() {
          const npcs = ref([])
          const form = ref({name:'NPC', prompt:'wander'})
          const running = ref(true)
          let ws = null
          let graph = null

          const createNpc = async ()=>{
            // ensure player_id present
            if(!form.value.player_id){
              alert('Please enter a Player ID before creating an NPC')
              return
            }
            // persist player id
            localStorage.setItem('aitown_player_id', form.value.player_id)
            await axios.post('/npc', { player_id: form.value.player_id, name: form.value.name, prompt: form.value.prompt })
            // server broadcasts update
          }

          const toggleSimulation = ()=>{
            running.value = !running.value
            if(ws && ws.readyState === WebSocket.OPEN){
              ws.send(JSON.stringify({type:'control', action: running.value ? 'start' : 'pause'}))
            }
          }

          const connectWs = ()=>{
            ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws')
            ws.onopen = ()=>{ console.log('ws open') }
            ws.onmessage = (ev)=>{
              const msg = JSON.parse(ev.data)
              if(msg.type === 'full_state'){
                npcs.value = msg.payload
                renderGraph()
              }
              if(msg.type === 'state_update'){
                // merge
                for(const u of msg.payload){
                  const idx = npcs.value.findIndex(n=>n.id===u.id)
                  if(idx>=0){ npcs.value[idx] = {...npcs.value[idx], ...u} }
                }
                renderGraph()
              }
              if(msg.type === 'npc_created'){
                npcs.value.push(msg.payload)
                renderGraph()
              }
              if(msg.type === 'npc_updated'){
                const idx = npcs.value.findIndex(n=>n.id===msg.payload.id)
                if(idx>=0) npcs.value[idx] = msg.payload
                renderGraph()
              }
            }
            ws.onclose = ()=>{ console.log('ws closed'); setTimeout(connectWs, 1000) }
          }

          const placesList = async ()=>{
            try{
              const r = await axios.get('/places')
              places.value = r.data
            }catch(e){ places.value = [] }
          }

          const renderGraph = ()=>{
            if(!graph){
              graph = new G6.Graph({
                container: 'mount',
                width: document.getElementById('mount').clientWidth,
                height: document.getElementById('mount').clientHeight,
                modes: { default: ['drag-canvas', 'zoom-canvas'] },
                defaultNode: { size: 20, style: { fill: '#5B8FF9' } }
              })
            }
            const nodes = npcs.value.map(n=>({ id: n.id, label: n.name, x: n.x*20 + 200, y: n.y*20 + 200 }))
            graph.data({ nodes, edges: [] })
            graph.render()
          }

          onMounted(async ()=>{
            // init player id from localStorage
            const pid = localStorage.getItem('aitown_player_id')
            if(pid) form.value.player_id = pid
            // load initial list and places
            const res = await axios.get('/npc')
            npcs.value = res.data
            await placesList()
            connectWs()
            renderGraph()
          })

          const places = ref([])
          const events = ref([])
          const selected = ref(null)
          const mapCells = ref([])

          function pushEvent(msg){
            events.value.unshift({ts: new Date().toLocaleTimeString(), txt: JSON.stringify(msg)})
            if(events.value.length>100) events.value.pop()
          }

          function selectNpc(id){
            const n = npcs.value.find(x=>x.id===id)
            selected.value = n
            // prefill prompt editor with current prompt
            editPromptText.value = n?.prompt || ''
            buildMap()
          }

          async function showMemory(){
            if(!selected.value) return
            const r = await axios.get('/npc/'+selected.value.id+'/memory')
            alert('Memory log: ' + JSON.stringify(r.data,null,2))
          }

          function buildMap(){
            // simple 5x5 centered at selected npc coords (x,y)
            const centerX = selected.value ? Math.round(selected.value.x||0) : 0
            const centerY = selected.value ? Math.round(selected.value.y||0) : 0
            const cells = []
            for(let dy=2; dy>=-2; dy--){
              for(let dx=-2; dx<=2; dx++){
                const x = centerX + dx
                const y = centerY + dy
                const place = places.value.find(p=>p.x===x && p.y===y) || null
                cells.push({k: x+','+y, x,y, label: x+','+y, place, center: dx===0 && dy===0})
              }
            }
            mapCells.value = cells
          }

          async function onCellClick(cell){
            // only selection/inspection allowed from UI; users can't trigger NPC actions directly
            if(!selected.value) return
            if(cell.place){
              pushEvent({evt:'cell_selected', id: selected.value.id, place: cell.place.id})
            } else {
              pushEvent({evt:'cell_selected', id: selected.value.id, place: null})
            }
          }

          const editPromptText = ref('')

          async function savePrompt(){
            if(!selected.value) return
            await axios.post('/npc/'+selected.value.id+'/prompt', { prompt: editPromptText.value }, { headers: {'X-Player-Id': selected.value.player_id} })
            pushEvent({evt:'prompt_saved', id: selected.value.id})
          }
          return { npcs, form, createNpc, running, toggleSimulation, places, events, selected, mapCells, selectNpc, showMemory, onCellClick, buildMap, editPromptText, savePrompt }
        }
      }).mount('#app')
    </script>
  </body>
</html>